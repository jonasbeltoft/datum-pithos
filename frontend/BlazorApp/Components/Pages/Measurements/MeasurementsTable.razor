@using BlazorApp.Services
@if (measurements == null || measurements.headers.Length == 0)
{
	<div class="flex-grow flex justify-center w-[85svw] max-w-[calc(100svw-20rem)]">

		<div class="loader"></div>

	</div>
}
else
{
	<div class="overflow-auto self-center max-w-full border rounded-lg">

		<table class="table-row text-sm">
			<thead class="sticky top-0 bg-white border-b">
				<tr class="text-left align-top">
					@foreach (var entry in measurements.headers)
					{
						<th class="p-4 border-r last-of-type:border-none">
							<span class="font-semibold mr-1">@entry.name</span>
							<span class="text-sm font-normal text-zinc-500">@entry.unit</span>
						</th>
					}
				</tr>
			</thead>
			<tbody>
				@for (int i = 0; i < measurements.entries.Count(); i++)
				{
					<tr
						class="border-b transition-colors odd:bg-zinc-100/50 hover:bg-zinc-200 hover:border-zinc-200 *:hover:border-zinc-50 data-[state=selected]:bg-muted last-of-type:border-none">
						@for (int j = 0; j < measurements.entries[i].measurements.Count(); j++)
						{

							int entry_index = i;
							int value_index = j;

							<td
								class="max-w-[20ch] text-ellipsis overflow-hidden whitespace-nowrap border-r last-of-type:border-none">
								<input
									class="m-2 p-2 w-[calc(100%-1rem)] ring-zinc-900 focus:outline-none rounded-md border-input bg-transparent text-sm ring-offset-background placeholder:text-zinc-500 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-30"
									placeholder="..." type="text" value="@measurements.entries[i].measurements[j]"
									@onchange="@((ChangeEventArgs args) => ValueChangedAsync(args, entry_index, value_index))">
							</td>
						}
					</tr>
				}
			</tbody>
		</table>
	</div>
}

@code {
	[Parameter]
	public int? measurementId { get; set; }

	[Parameter]
	public EventCallback<bool> OnFetchSuccess { get; set; }

	public MeasurementCollection? measurements { get; set; }
	protected async override Task OnParametersSetAsync()
	{
		// FETCH THE INITIAL DATA
	}

	private async void ValueChangedAsync(ChangeEventArgs args, int entry_index, int value_index) //
	{
		measurements!.entries[entry_index].measurements[value_index] = args.Value!.ToString();

		for (int i = 0; i < measurements.entries.Count(); i++)
		{
			Console.WriteLine("[{0}]", string.Join(", ", measurements.entries[i].measurements));
		}
	}

	protected override async Task OnInitializedAsync()
	{

		await FetchMeasurements();

	}

	private async Task FetchMeasurements()
	{

		measurements = new MeasurementCollection { };
		// HTTP CALL
		await Task.Delay(500);

		// Define headers
		var headers = new MeasurementHeader[]
		{
new MeasurementHeader { name = "Date", unit = "Time" },
new MeasurementHeader { name = "Temperature", unit = "Celsius" },
new MeasurementHeader { name = "Pressure", unit = "Pascal" },
new MeasurementHeader { name = "Humidity", unit = "%" },
new MeasurementHeader { name = "Flow Rate", unit = "L/s" },
new MeasurementHeader { name = "Voltage", unit = "V" },
new MeasurementHeader { name = "Ph" },
new MeasurementHeader { name = "Temperature", unit = "Celsius" },
new MeasurementHeader { name = "Pressure", unit = "Pascal" },
new MeasurementHeader { name = "Humidity", unit = "%" }
		};

		// Generate 50 entries with some missing values
		var random = new Random();
		var _measurements = new Measurement[5];
		for (int i = 0; i < 5; i++)
		{
			// Create a row of measurements with potential "holes"
			string[] row = new string[headers.Length];
			for (int j = 0; j < headers.Length; j++)
			{
				// Randomly leave some entries empty
				row[j] = random.Next(0, 100) > 30 // 70% chance to have a value
				? random.Next(1, 100).ToString() // Random value
				: ""; // Empty string to simulate "hole"
			}
			_measurements[i] = new Measurement { measurements = row };
		}
		_measurements = _measurements
		.OrderByDescending(entry =>
		{
			int val = 0;
			int.TryParse(entry.measurements[0], out val);
			return val;
		})
		.ToArray();
		// Create the MeasurementCollection
		measurements = new MeasurementCollection
		{
			headers = headers,
			entries = _measurements
		};
		@* for (int i = 0; i < _measurements.Count(); i++)
		{
			Console.WriteLine("[{0}]", string.Join(", ", _measurements[i].measurements));
		} *@

		// Notify parent component of success
		await OnFetchSuccess.InvokeAsync(true);
	}

}
